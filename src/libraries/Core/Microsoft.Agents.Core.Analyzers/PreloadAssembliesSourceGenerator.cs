// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using Microsoft.Agents.Core.Analyzers.Extensions;
using Microsoft.Agents.Core.Analyzers.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Microsoft.Agents.Core.Analyzers
{
    /// <summary>
    /// Generates a ModuleInitializer to force loading of assemblies that contain Microsoft.Agents.Core subtypes.
    /// </summary>
    [Generator]
    [ExcludeFromCodeCoverage]
    public class PreloadAssembliesSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            if (!Debugger.IsAttached)
            {
                //Debugger.Launch();
            }

            // Step 1: get the Compilation
            var compilationProvider = context.CompilationProvider;

            // Step 2: resolve MyType
            var myTypeProvider = compilationProvider
                .Select(static (compilation, _) => compilation.GetTypeByMetadataName("Microsoft.Agents.Core.Models.Entity"));

            // Step 3: find derived types in referenced assemblies
            var derivedTypesProvider =
                compilationProvider
                    .Combine(myTypeProvider)
                    .Select(static (pair, ct) => FindDerivedTypes(pair.Left, pair.Right))
#pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.
                    // Custom comparer expects string?, but we guarantee non-null strings in FindDerivedTypes.
                    .WithComparer(new ObjectImmutableArraySequenceEqualityComparer<string>());
#pragma warning restore CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.

            // Step 4: generate source
            context.RegisterSourceOutput(
                derivedTypesProvider,
                static (spc, derivedTypes) =>
                {
                    if (derivedTypes.IsDefaultOrEmpty)
                    {
                        return;
                    }

                    var source = GenerateSource(derivedTypes);
                    spc.AddSource("PreloadedAssemblies.g.cs", SourceText.From(source, System.Text.Encoding.UTF8));
                });
        }

        private static ImmutableArray<string> FindDerivedTypes(
            Compilation compilation,
            INamedTypeSymbol? myType)
        {
            if (myType is null)
                return ImmutableArray<string>.Empty;

            var builder = ImmutableArray.CreateBuilder<string>();

            foreach (var assembly in compilation.References
                         .Select(compilation.GetAssemblyOrModuleSymbol)
                         .OfType<IAssemblySymbol>())
            {
                CollectAnyDerivedType(assembly.GlobalNamespace, myType, builder);
            }

            return builder.ToImmutable();
        }

        private static void CollectAnyDerivedType(
            INamespaceSymbol ns,
            INamedTypeSymbol baseType,
            ImmutableArray<string>.Builder builder)
        {
            foreach (var member in ns.GetMembers())
            {
                if (member is INamespaceSymbol childNs)
                {
                    CollectAnyDerivedType(childNs, baseType, builder);
                }
                else if (member is INamedTypeSymbol type)
                {
                    if (type.InheritsFrom(baseType))
                    {
                        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (!name.StartsWith("global::Microsoft.Agents.Core.Models"))
                        {
                            builder.Add(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        }
                    }
                }
            }
        }

        private static string GenerateSource(ImmutableArray<string> types)
        {
            var sb = new System.Text.StringBuilder();

            var typesAsStrings = types.Distinct().Select(x => $"typeof({x})");

            sb.AppendFormat(/* lang=c#-test */ """
            // <auto-generated />
            using System;
            using System.Runtime.CompilerServices;
            using Microsoft.Agents.Core.Serialization;

            [assembly: Microsoft.Agents.Core.Serialization.SerializationInitAssemblyAttribute(typeof(global::PreloadTypesRegistry))]

            internal class PreloadTypesRegistry
            {{
                private static readonly Type[] s_preloadedTypes;
                static PreloadTypesRegistry()
                {{
                    s_preloadedTypes = new[]
                    {{
                        {0}
                    }};
                }}

                //[ModuleInitializer]
                public static void Init()
                {{
                    _ = s_preloadedTypes.Length;
                }}
            }}
            """,
            string.Join(",\r\n            ", typesAsStrings));

            return sb.ToString();
        }
    }
}