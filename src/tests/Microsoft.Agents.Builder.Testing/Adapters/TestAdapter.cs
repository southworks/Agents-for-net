// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Agents.Builder.Testing.Adapters;
using Microsoft.Agents.Connector;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;

namespace Microsoft.Agents.Builder.Testing
{
    /// <summary>
    /// A mock adapter that can be used for unit testing of bot logic.
    /// </summary>
    /// <seealso cref="TestFlow"/>
    public class TestAdapter : ChannelAdapter
    {
        private bool _sendTraceActivity;
        private readonly object _conversationLock = new object();
        private readonly object _activeQueueLock = new object();
        private readonly MockUserTokenClient _userTokenClient = new MockUserTokenClient();

        private int _nextId = 0;
        private Queue<TaskCompletionSource<IActivity>> _queuedRequests = new Queue<TaskCompletionSource<IActivity>>();

        /// <summary>
        /// Initializes a new instance of the <see cref="TestAdapter"/> class.
        /// </summary>
        /// <param name="channelId">The target <see cref="Channels"/> for the test the will be passed to the bot.</param>
        /// <param name="sendTraceActivity">Indicates whether the adapter should add to its <see cref="ActiveQueue"/>
        /// <param name="logger">Logger for this class</param>
        /// any trace activities generated by the bot.</param>
        public TestAdapter(string channelId, bool sendTraceActivity = false, ILogger logger = null) : base (logger)
        {
            _sendTraceActivity = sendTraceActivity;

            Conversation = new ConversationReference
            {
                ChannelId = channelId,
                ServiceUrl = "https://test.com",
                User = new ChannelAccount("user1", "User1"),
                Agent = new ChannelAccount("bot", "Bot"),
                Conversation = new ConversationAccount(false, "convo1", "Conversation1"),
                Locale = this.Locale,
            };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TestAdapter"/> class.
        /// </summary>
        /// <param name="conversation">A reference to the conversation to begin the adapter state with.</param>
        /// <param name="sendTraceActivity">Indicates whether the adapter should add to its <see cref="ActiveQueue"/>
        /// <param name="logger">Logger for this class</param>
        /// any trace activities generated by the bot.</param>
        public TestAdapter(ConversationReference conversation = null, bool sendTraceActivity = false, ILogger logger = null) : base(logger)
        {
            _sendTraceActivity = sendTraceActivity;
            if (conversation != null)
            {
                Conversation = conversation;
            }
            else
            {
                Conversation = new ConversationReference
                {
                    ChannelId = Channels.Test,
                    ServiceUrl = "https://test.com",
                    User = new ChannelAccount("user1", "User1"),
                    Agent = new ChannelAccount("bot", "Bot"),
                    Conversation = new ConversationAccount(false, "convo1", "Conversation1"),
                    Locale = this.Locale,
                };
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to send trace activities.
        /// </summary>
        /// <value>
        /// A value indicating whether to send trace activities.
        /// </value>
        public bool EnableTrace
        {
            get => _sendTraceActivity;
            set => this._sendTraceActivity = value;
        }

        /// <summary>
        /// Gets or sets the locale for the conversation.
        /// </summary>
        /// <value>
        /// The locale for the conversation.
        /// </value>
        public string Locale { get; set; } = "en-us";

        /// <summary>
        /// Gets the queue of responses from the bot.
        /// </summary>
        /// <value>The queue of responses from the bot.</value>
        public Queue<IActivity> ActiveQueue { get; } = new Queue<IActivity>();

        /// <summary>
        /// Gets or sets a reference to the current conversation.
        /// </summary>
        /// <value>A reference to the current conversation.</value>
        public ConversationReference Conversation { get; set; }

        /// <summary>
        /// Create a ConversationReference. 
        /// </summary>
        /// <param name="name">name of the conversation (also ID).</param>
        /// <param name="user">name of the user (also ID) default:User1.</param>
        /// <param name="bot">name of the bot (also ID) default:Bot.</param>
        /// <returns>ConversationReference.</returns>
        public static ConversationReference CreateConversation(string name, string user = "User1", string bot = "Bot")
        {
            return new ConversationReference
            {
                ChannelId = "test",
                ServiceUrl = "https://test.com",
                Conversation = new ConversationAccount(false, name, name),
                User = new ChannelAccount(id: user.ToLowerInvariant(), name: user),
                Agent = new ChannelAccount(id: bot.ToLowerInvariant(), name: bot),
                Locale = "en-us"
            };
        }

        /// <summary>
        /// Adds middleware to the adapter's pipeline.
        /// </summary>
        /// <param name="middleware">The middleware to add.</param>
        /// <returns>The updated adapter object.</returns>
        /// <remarks>Middleware is added to the adapter at initialization time.
        /// For each turn, the adapter calls middleware in the order in which you added it.
        /// </remarks>
        public new TestAdapter Use(IMiddleware middleware)
        {
            base.Use(middleware);
            return this;
        }

        public async Task<InvokeResponse> ProcessActivityAsync(IActivity activity, AgentCallbackHandler callback, CancellationToken cancellationToken)
        {
            return await ProcessActivityAsync(ClaimsIdentity, activity, callback, cancellationToken);
        }

        /// <summary>
        /// Receives an activity and runs it through the middleware pipeline.
        /// </summary>
        /// <param name="activity">The activity to process.</param>
        /// <param name="callback">The bot logic to invoke.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects
        /// or threads to receive notice of cancellation.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        public override async Task<InvokeResponse> ProcessActivityAsync(ClaimsIdentity claimsIdentity, IActivity activity, AgentCallbackHandler callback, CancellationToken cancellationToken)
        {
            lock (_conversationLock)
            {
                // ready for next reply
                if (activity.Type == null)
                {
                    activity.Type = ActivityTypes.Message;
                }

                if (activity.ChannelId == null)
                {
                    activity.ChannelId = Conversation.ChannelId;
                }

                if (activity.From == null || activity.From.Id == "unknown" || activity.From.Role == RoleTypes.Agent)
                {
                    activity.From = Conversation.User;
                }

                activity.Recipient = Conversation.Agent;
                activity.Conversation = Conversation.Conversation;
                activity.ServiceUrl = Conversation.ServiceUrl;

                var id = activity.Id = (_nextId++).ToString(CultureInfo.InvariantCulture);
            }

            if (activity.Timestamp == null || activity.Timestamp == default(DateTimeOffset))
            {
                activity.Timestamp = DateTimeOffset.UtcNow;
            }

            if (activity.LocalTimestamp == null || activity.LocalTimestamp == default(DateTimeOffset))
            {
                activity.LocalTimestamp = DateTimeOffset.Now;
            }

            // note here Dispose is NOT called on the TurnContext because we want to use it later in the test code
            var context = CreateTurnContext(activity);
            await RunPipelineAsync(context, callback, cancellationToken).ConfigureAwait(false);

            return null;
        }

        public override async Task ProcessProactiveAsync(ClaimsIdentity claimsIdentity, IActivity continuationActivity, IAgent bot, CancellationToken cancellationToken, string audience = null)
        {
            await ProcessProactiveAsync(claimsIdentity, continuationActivity, audience, bot.OnTurnAsync, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// The implementation for continue conversation.
        /// </summary>
        /// <param name="claimsIdentity">A <see cref="ClaimsIdentity"/> for the conversation.</param>
        /// <param name="continuationActivity">The continuation <see cref="Activity"/> used to create the <see cref="ITurnContext" />.</param>
        /// <param name="audience">The audience for the call.</param>
        /// <param name="callback">The method to call for the resulting bot turn.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <param name="async"></param>
        /// <returns>A task that represents the work queued to execute.</returns>
        public override async Task ProcessProactiveAsync(ClaimsIdentity claimsIdentity, IActivity continuationActivity, string audience, AgentCallbackHandler callback, CancellationToken cancellationToken)
        {
            var context = CreateTurnContext(continuationActivity);
            await RunPipelineAsync(context, callback, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Sends activities to the conversation.
        /// </summary>
        /// <param name="turnContext">Context for the current turn of conversation.</param>
        /// <param name="activities">The activities to send.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects
        /// or threads to receive notice of cancellation.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        /// <remarks>If the activities are successfully sent, the task result contains
        /// an array of <see cref="ResourceResponse"/> objects containing the IDs that
        /// the receiving channel assigned to the activities.</remarks>
        /// <seealso cref="ITurnContext.OnSendActivities(SendActivitiesHandler)"/>
        public override async Task<ResourceResponse[]> SendActivitiesAsync(ITurnContext turnContext, IActivity[] activities, CancellationToken cancellationToken)
        {
            if (turnContext == null)
            {
                throw new ArgumentNullException(nameof(turnContext));
            }

            if (activities == null)
            {
                throw new ArgumentNullException(nameof(activities));
            }

            if (activities.Length == 0)
            {
                throw new ArgumentException("Expecting one or more activities, but the array was empty.", nameof(activities));
            }

            var responses = new ResourceResponse[activities.Length];

            // NOTE: we're using for here (vs. foreach) because we want to simultaneously index into the
            // activities array to get the activity to process as well as use that index to assign
            // the response to the responses array and this is the most cost effective way to do that.
            for (var index = 0; index < activities.Length; index++)
            {
                var activity = activities[index];

                if (string.IsNullOrEmpty(activity.Id))
                {
                    activity.Id = Guid.NewGuid().ToString("n");
                }

                if (activity.Timestamp == null)
                {
                    activity.Timestamp = DateTime.UtcNow;
                }

                if (activity.Type == ActivityTypes.Delay)
                {
                    // The BotFrameworkAdapter and Console adapter implement this
                    // directly in the POST method. Replicating that here
                    // to keep the behavior as close as possible to facilitate
                    // more realistic tests.
                    var delayMs = Convert.ToInt32(activity.Value, CultureInfo.InvariantCulture);

                    await Task.Delay(delayMs).ConfigureAwait(false);
                }
                else if (activity.Type == ActivityTypes.Trace)
                {
                    if (_sendTraceActivity)
                    {
                        Enqueue(activity);
                    }
                }
                else
                {
                    Enqueue(activity);
                }

                responses[index] = new ResourceResponse(activity.Id);
            }

            return responses;
        }

        /// <summary>
        /// Replaces an existing activity in the <see cref="ActiveQueue"/>.
        /// </summary>
        /// <param name="turnContext">Context for the current turn of conversation.</param>
        /// <param name="activity">New replacement activity.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects
        /// or threads to receive notice of cancellation.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        /// <remarks>If the activity is successfully sent, the task result contains
        /// a <see cref="ResourceResponse"/> object containing the ID that the receiving
        /// channel assigned to the activity.
        /// <para>Before calling this, set the ID of the replacement activity to the ID
        /// of the activity to replace.</para></remarks>
        /// <seealso cref="ITurnContext.OnUpdateActivity(UpdateActivityHandler)"/>
        public override Task<ResourceResponse> UpdateActivityAsync(ITurnContext turnContext, IActivity activity, CancellationToken cancellationToken)
        {
            lock (_activeQueueLock)
            {
                var replies = ActiveQueue.ToList();
                for (int i = 0; i < ActiveQueue.Count; i++)
                {
                    if (replies[i].Id == activity.Id)
                    {
                        replies[i] = activity;
                        ActiveQueue.Clear();
                        foreach (var item in replies)
                        {
                            ActiveQueue.Enqueue(item);
                        }

                        return Task.FromResult(new ResourceResponse(activity.Id));
                    }
                }
            }

            return Task.FromResult(new ResourceResponse());
        }

        /// <summary>
        /// Deletes an existing activity in the <see cref="ActiveQueue"/>.
        /// </summary>
        /// <param name="turnContext">Context for the current turn of conversation.</param>
        /// <param name="reference">Conversation reference for the activity to delete.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects
        /// or threads to receive notice of cancellation.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        /// <remarks>The <see cref="ConversationReference.ActivityId"/> of the conversation
        /// reference identifies the activity to delete.</remarks>
        /// <seealso cref="ITurnContext.OnDeleteActivity(DeleteActivityHandler)"/>
        public override Task DeleteActivityAsync(ITurnContext turnContext, ConversationReference reference, CancellationToken cancellationToken)
        {
            lock (_activeQueueLock)
            {
                var replies = ActiveQueue.ToList();
                for (int i = 0; i < ActiveQueue.Count; i++)
                {
                    if (replies[i].Id == reference.ActivityId)
                    {
                        replies.RemoveAt(i);
                        ActiveQueue.Clear();
                        foreach (var item in replies)
                        {
                            ActiveQueue.Enqueue(item);
                        }

                        break;
                    }
                }
            }

            return Task.CompletedTask;
        }

        /// <summary>
        /// Creates a new conversation on the specified channel.
        /// </summary>
        /// <param name="channelId">The ID of the channel.</param>
        /// <param name="callback">The bot logic to call when the conversation is created.</param>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects
        /// or threads to receive notice of cancellation.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        /// <remarks>This resets the <see cref="ActiveQueue"/>, and does not maintain multiple conversation queues.</remarks>
        public Task CreateConversationAsync(string channelId, AgentCallbackHandler callback, CancellationToken cancellationToken)
        {
            ActiveQueue.Clear();
            var update = Activity.CreateConversationUpdateActivity();
            update.ChannelId = channelId;
            update.Conversation = new ConversationAccount { Id = Guid.NewGuid().ToString("n") };
            using (var context = CreateTurnContext((Activity)update))
            {
                return callback(context, cancellationToken);
            }
        }

        /// <summary>
        /// Dequeues and returns the next bot response from the <see cref="ActiveQueue"/>.
        /// </summary>
        /// <returns>The next activity in the queue; or null, if the queue is empty.</returns>
        /// <remarks>A <see cref="TestFlow"/> object calls this to get the next response from the bot.</remarks>
        public IActivity GetNextReply()
        {
            lock (_activeQueueLock)
            {
                if (ActiveQueue.Count > 0)
                {
                    return ActiveQueue.Dequeue();
                }
            }

            return null;
        }

        /// <summary>
        /// Get the next reply async.
        /// </summary>
        /// <param name="cancellationToken">cancellation Token.</param>
        /// <returns>activity when it's available or canceled task if it is canceled.</returns>
        public Task<IActivity> GetNextReplyAsync(CancellationToken cancellationToken = default)
        {
            lock (_activeQueueLock)
            {
                if (!_queuedRequests.Any())
                {
                    var result = GetNextReply();
                    if (result != null)
                    {
                        return Task.FromResult(result);
                    }
                }

                var tcs = new TaskCompletionSource<IActivity>();
                cancellationToken.Register(() => tcs.SetCanceled());
                this._queuedRequests.Enqueue(tcs);
                return tcs.Task;
            }
        }

        /// <summary>
        /// Creates a message activity from text and the current conversational context.
        /// </summary>
        /// <param name="text">The message text.</param>
        /// <returns>An appropriate message activity.</returns>
        /// <remarks>A <see cref="TestFlow"/> object calls this to get a message activity
        /// appropriate to the current conversation.</remarks>
        public Activity MakeActivity(string text = null)
        {
            Activity activity = new Activity
            {
                Type = ActivityTypes.Message,
                Locale = this.Locale ?? "en-us",
                From = Conversation.User,
                Recipient = Conversation.Agent,
                Conversation = Conversation.Conversation,
                ServiceUrl = Conversation.ServiceUrl,
                Id = (_nextId++).ToString(CultureInfo.InvariantCulture),
                Text = text,
            };

            return activity;
        }

        public ClaimsIdentity ClaimsIdentity { get; set; }

        /// <summary>
        /// Processes a message activity from a user.
        /// </summary>
        /// <param name="userSays">The text of the user's message.</param>
        /// <param name="callback">The turn processing logic to use.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>A task that represents the work queued to execute.</returns>
        /// <seealso cref="TestFlow.Send(string)"/>
        public virtual Task SendTextToBotAsync(string userSays, AgentCallbackHandler callback, CancellationToken cancellationToken)
        {
            return ProcessActivityAsync(ClaimsIdentity, MakeActivity(userSays), callback, cancellationToken);
        }

        /// <summary>
        /// Adds a fake user token so it can later be retrieved.
        /// </summary>
        /// <param name="connectionName">The connection name.</param>
        /// <param name="channelId">The channel ID.</param>
        /// <param name="userId">The user ID.</param>
        /// <param name="token">The token to store.</param>
        /// <param name="magicCode">The optional magic code to associate with this token.</param>
        public void AddUserToken(string connectionName, string channelId, string userId, string token, string magicCode = null)
        {
            _userTokenClient.AddUserToken(connectionName, channelId, userId, token, magicCode);
        }

        /// <summary>
        /// Adds a fake exchangeable token so it can be exchanged later.
        /// </summary>
        /// <param name="connectionName">The connection name.</param>
        /// <param name="channelId">The channel ID.</param>
        /// <param name="userId">The user ID.</param>
        /// <param name="exchangableItem">The exchangeable token or resource URI.</param>
        /// <param name="token">The token to store.</param>
        public void AddExchangeableToken(string connectionName, string channelId, string userId, string exchangableItem, string token)
        {
            _userTokenClient.AddExchangeableToken(connectionName, channelId,userId, exchangableItem, token);
        }

        /// <summary> Adds an instruction to throw an exception during exchange requests.
        /// </summary>
        /// <param name="connectionName">The connection name.</param>
        /// <param name="channelId">The channel ID.</param>
        /// <param name="userId">The user ID.</param>
        /// <param name="exchangableItem">The exchangeable token or resource URI.</param>
        public void ThrowOnExchangeRequest(string connectionName, string channelId, string userId, string exchangableItem)
        {
            _userTokenClient.ThrowOnExchangeRequest(connectionName,channelId, userId, exchangableItem);
        }

        /// <summary>
        /// Creates the turn context for the adapter.
        /// </summary>
        /// <param name="activity">An <see cref="Activity"/> instance for the turn.</param>
        /// <returns>A <see cref="TurnContext"/> instance to be used by the adapter.</returns>
        public virtual TurnContext CreateTurnContext(IActivity activity, ClaimsIdentity identity = null)
        {
            var turnContext = new TurnContext(this, activity);

            turnContext.Services.Set<IUserTokenClient>(_userTokenClient);
            turnContext.Identity = identity ?? ClaimsIdentity;

            return turnContext;
        }

        private void Enqueue(IActivity activity)
        {
            lock (_activeQueueLock)
            {
                // if there are pending requests, fulfill them with the activity.
                while (_queuedRequests.Any())
                {
                    var tcs = _queuedRequests.Dequeue();
                    if (tcs.Task.IsCanceled == false)
                    {
                        tcs.SetResult(activity);
                        return;
                    }
                }

                // else we enqueue for next requester
                ActiveQueue.Enqueue(activity);
            }
        }
    }
}
